import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import sharp from "sharp";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, "..");
const itemsDir = path.join(repoRoot, "src", "data", "portfolio", "items");
const siteContentFile = path.join(repoRoot, "src", "data", "siteContent.js");
const outputFile = path.join(repoRoot, "src", "data", "imageLqipMap.js");

function isLocalPublicImage(src) {
  return typeof src === "string" && src.startsWith("/") && !src.startsWith("//");
}

function publicPathToAbsoluteFile(src) {
  // src like: /images/foo/bar.webp
  return path.join(repoRoot, "public", src);
}

async function getTextFilePathsToScan() {
  const entries = await fs.readdir(itemsDir, { withFileTypes: true });
  const itemFiles = entries
    .filter((entry) => entry.isFile() && entry.name.endsWith(".js"))
    .map((entry) => path.join(itemsDir, entry.name));

  return [siteContentFile, ...itemFiles];
}

async function collectImageSrcsFromFiles(filePaths) {
  const srcs = new Set();
  const imagePathRegex = /["'](\/images\/[^"']+)["']/g;

  for (const filePath of filePaths) {
    let text;
    try {
      text = await fs.readFile(filePath, "utf8");
    } catch {
      continue;
    }

    for (const match of text.matchAll(imagePathRegex)) {
      const src = match[1];
      if (isLocalPublicImage(src)) srcs.add(src);
    }
  }

  return srcs;
}

async function generateBlurDataURL(absFilePath) {
  // Keep this small to avoid bloating HTML/JS.
  const buffer = await sharp(absFilePath)
    .resize({ width: 48 })
    .blur(6)
    .webp({ quality: 55 })
    .toBuffer();

  return `data:image/webp;base64,${buffer.toString("base64")}`;
}

function toGeneratedModule(map) {
  const header = `// This file is auto-generated by scripts/generate-lqip.mjs
// Do not edit manually.

`;

  const keys = Object.keys(map).sort((a, b) => a.localeCompare(b));
  const lines = keys.map((key) => `  ${JSON.stringify(key)}: ${JSON.stringify(map[key])},`);

  return (
    header +
    `const IMAGE_LQIP_MAP = {\n${lines.join("\n")}\n};\n\nexport default IMAGE_LQIP_MAP;\n`
  );
}

async function main() {
  const filePaths = await getTextFilePathsToScan();
  const srcSet = await collectImageSrcsFromFiles(filePaths);
  const srcs = Array.from(srcSet).sort((a, b) => a.localeCompare(b));

  const map = {};
  const missing = [];

  for (const src of srcs) {
    const abs = publicPathToAbsoluteFile(src);
    try {
      await fs.access(abs);
      map[src] = await generateBlurDataURL(abs);
    } catch {
      missing.push(src);
    }
  }

  await fs.writeFile(outputFile, toGeneratedModule(map), "utf8");

  if (missing.length > 0) {
    console.warn(`⚠️  Missing files for ${missing.length} image(s):`);
    for (const src of missing) console.warn(`- ${src}`);
  }

  console.log(`✅ Generated LQIP map for ${Object.keys(map).length} image(s)`);
  console.log(`→ ${path.relative(repoRoot, outputFile)}`);
}

main().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
